树变二叉树:
将树转换成二叉树的步骤是：
（1）加线。就是在所有兄弟结点之间加一条连线；
（2）抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；
（3）旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。

非叶节点都对应一个无右孩子的节点,根节点也没有右孩子.



N0 = 2 * N2+1


Huffman变种: |
    m表示节点个数
    k表示K叉树
    若（m-1）%(k-1) = 0说明不需要虚段，否则需要（K-1）-（m-1）%(k-1)个虚段。
    本题m=6,k=3。
    则（6-1）%（3-1）=1
    需要虚段 2 - 1 = 1添加的虚段可视为0。然后按照优先取最小的三个的原则，构造三叉树。

平衡二叉树(AVL): |
 1. 他是二叉查找树
 2. 每个节点高度差至多为1


二叉树的高度与深度:
 - 高度,是一个树中的概念,是跟节点到最远叶子节点的节点数
 - 深度,是节点中的概念,是节点到根的距离(节点数)
 - tmd,居然又初值为一和为0的两种概念....


最小生成树算法:
    - Kruskal算法(加边法)选择最小的边;比较优
    - Prim算法(加点法)(贪心),,往最小生成树点集中加入最小代价(边)的点
    - Sollin（Boruvka)算法...
    - Dijkstra算法: 某个源点到其余各顶点的最短路径;path i 表示从源点到顶点i之间最短路径的前驱节点.

哈夫曼(Huffman)树:
    - 带权路径长度最小
    - 叶节点有实际元素.

B树(B-树):
    定义:
        - m阶B树
        - 每个节点最多有m-1个关键字
        - 根节点最好可以只有一个关键字
        - 非根节点至少有Math.ceil(m/2) -1 个关键字,ceil 向上取整
        - 每个节点中的关键字都从小到大的顺序排列
        - 所有叶子节点都位于同一层
    杂: 阶数表示了一个节点最多有多少个孩子节点
    插入: 找到要插入的位置,若超过容量,将中间的元素插入到父节点中,左右两边元素分裂成两棵子数
    删除: ...要借,要补...

B+树: 相对B树,非叶节点只有索引,没有实值,所有实值皆在叶子节点上


排序:
    插入排序:
        直接插入排序: 顺序查找,后移覆盖
        折半插入排序: 折半查找...
        希尔排序: 特殊子表(i,i+d,i+2d),先直插排序,再对全体直插排序,d1=n/2,di+1 = floor(di/2);分组(少到全)直插
    交换排序:
        冒泡排序: 从后往前,两两比较,交换来排序
        快速排序: 分治,基准,左右两边大小分开,递归
    选择排序:
        简单选择排序: 选最小的与待排序列开头交换
        堆排序(二叉堆): 完全二叉树顺序存储结构(非遍历顺序)(根,左,右,左左,右右,左左左...).根节点元素大于或小于节点元素;2i,2i+1;
    归并和基数排序:
        归并排序: 两个或两个以上的有序表组成一个新的表
        基数排序: 从低位到高位排序...

关键路径算法: |
    AOE 网
    顶点表事件,边表活动
    事件对前驱有全依赖性(前驱全完成后才能开始);star
    算的是,,没有可拖延时间的活动,,总的路径叫关键路径
    ve(i),事件i的最早发生时间,前面的全完成后启动i的最早时间,最大值
    vl(i),事件i的最迟发生时间,从后往前算,最小的时间点,最小值
    e(i),活动开始的最早开始时间,跟开始时间最早开始时间一致
    l(i),终点所表示的事件最迟发生时间与该活动所需时间之差,< j,k >,vl(k)-w(j,k)
    d(i)=l(i)-e(i) = 0
    关键活动要涵盖关键路径