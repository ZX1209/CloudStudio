对比,table

键值



字符串模式匹配:
    简单的模式匹配: null
    改进的模式匹配(KMP):
        - 利用部分匹配的结果(最长公共前缀);
        - 字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串;
        - 排除当前的前面的比较结果,当要算next[j]时,意味着,j位没有对应上,next[j]是,公共前缀之后一个位置.因为前面的看作相同的,就要比较后一位是否相同.next的更新也是看这个;
        - ;这个next居然是1开头的,0保留.也对.;k=next[j-1],是为了next[j]=k+1,有两层跳跃;
        - ;next[j]是j错了前面的最长前缀后面的一位.

主存与Cache间的地址映射:
    全相联映射方式:对于主存中的数据块可以拷贝到cache中的哪一行不做硬性规定。
    直接映射方式: 相当于将主存空间按cache的大小（行数）进行分区（说“分组”也可以），主存分区（组）后，每区（组）中的数据块数目与cache的行数一致。
    组相连映射: cache的分组数=主存每一组的块数;将cache的空间分为若干组，主存块与cache组之间直接映射，而组内各块之间全相联映射。

微程序:
    微指令:
        微操作命令: 微命令是微操作的控制信号，微操作是微命令的执行过程。

# 相容性的微命令放在不同组，互斥性的命令放在一组。

字段直接编码: 就是把微命令分多个段，段的数目等于互斥类的数目。因此这里分为5个段，每段里要留一个离散状态表示自己没命令。所以7个微命令对应3位，3个微命令对应2位，12个微命令对应4位，5个微命令对应3位，6个微命令对应3位，共15位。

read系统调用:
    - 若文件的数据不在内存中，则进程进入睡眠模式的目的是等待内存对磁盘上文件的映射，因为磁盘的读取比较慢，所以事进入睡眠模式。
    - read是系统调用，所以CPU从用户态切换到核心态。
    - open系统调用应该包含文件的名称，read只是包含输入流


RL旋转: 新加的做根.其余做子数接到根上.