直接字符接空值: 作为默认的一个列表容器?
对比,table:

键值:

进制转换: 
    二转八 :
    二转十 :
    十转任意 :
        基数乘除法:
            除基取余法 : (整数部分的转换),整数部分除基取余,最先得到的余数为数的最低位(右),最后得到的余数为数的最高位(左)
            乘基取整法 : (小数部分的转换),小数部分乘基取整,最先取到的整数为数的最高位,最后取到的整数为数的最低位



字符串模式匹配:
    简单的模式匹配: null
    改进的模式匹配(KMP):
        - 利用部分匹配的结果(最长公共前缀);
        - 字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串;
        - 排除当前的前面的比较结果,当要算next[j]时,意味着,j位没有对应上,next[j]是,公共前缀之后一个位置.因为前面的看作相同的,就要比较后一位是否相同.next的更新也是看这个;
        - ;这个next居然是1开头的,0保留.也对.;k=next[j-1],是为了next[j]=k+1,有两层跳跃;
        - ;next[j]是j错了前面的最长前缀后面的一位.

主存与Cache间的地址映射:
    全相联映射方式: 对于主存中的数据块可以拷贝到cache中的哪一行不做硬性规定。标记即为主存块号
    直接映射方式: 相当于将主存空间按cache的行数进行分组,主存块号的低c位正好是对应的Cache行号,块号高t位最为Cache行的标记,标记装入的是哪块,似乎还有个有效位
    组相连映射: cache的分组数=主存每一组的块数;将cache的空间分为若干组，主存块与cache组之间直接映射，而组内各块之间全相联映射。主存分组按照连续的几块来分组,主存分区(Cache行数)来分辨装填到Cache同一组的主存组

微程序:
    微指令:
        微操作命令: 微命令是微操作的控制信号，微操作是微命令的执行过程。

# 相容性的微命令放在不同组，互斥性的命令放在一组。

字段直接编码: 就是把微命令分多个段，段的数目等于互斥类的数目。因此这里分为5个段，每段里要留一个离散状态表示自己没命令。所以7个微命令对应3位，3个微命令对应2位，12个微命令对应4位，5个微命令对应3位，6个微命令对应3位，共15位。

read系统调用:
    - 若文件的数据不在内存中，则进程进入睡眠模式的目的是等待内存对磁盘上文件的映射，因为磁盘的读取比较慢，所以事进入睡眠模式。
    - read是系统调用，所以CPU从用户态切换到核心态。
    - open系统调用应该包含文件的名称，read只是包含输入流


RL旋转: 新加的做根.其余做子数接到根上.