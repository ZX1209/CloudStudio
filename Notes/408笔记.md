对比,table

键值

平衡二叉树(AVL): |
 1. 他是二叉查找树
 2. 每个节点高度差至多为1


二叉树的高度与深度:
 - 高度,是一个树中的概念,是跟节点到最远叶子节点的节点数
 - 深度,是节点中的概念,是节点到根的距离(节点数)
 - tmd,居然又初值为一和为0的两种概念....


最小生成树算法:
    - Kruskal算法(加边法)选择最小的边;比较优
    - Prim算法(加点法)(贪心),,往最小生成树点集中加入最小代价(边)的点
    - Sollin（Boruvka)算法...
    - Dijkstra算法: 某个源点到其余各顶点的最短路径;path i 表示从源点到顶点i之间最短路径的前驱节点.

哈夫曼(Huffman)树:
    - 带权路径长度最小
    - 叶节点有实际元素.

B树(B-树):
    定义:
        - m阶B树
        - 每个节点最多有m-1个关键字
        - 根节点最好可以只有一个关键字
        - 非根节点至少有Math.ceil(m/2) -1 个关键字
        - 每个节点中的关键字都从小到大的顺序排列
        - 所有叶子节点都位于同一层
    杂: 阶数表示了一个节点最多有多少个孩子节点
    插入: 找到要插入的位置,若超过容量,将中间的元素插入到父节点中,左右两边元素分裂成两棵子数
    删除: ...要借,要补...

B+树: 相对B树,非叶节点只有索引,没有实值,所有实值皆在叶子节点上


排序:
    插入排序:
        直接插入排序: 顺序查找,后移覆盖
        折半插入排序: 折半查找...
        希尔排序: 特殊子表(i,i+d,i+2d),先直插排序,再对全体直插排序,d1=n/2,di+1 = floor(di/2);分组(少到全)直插
    交换排序:
        冒泡排序: 从后往前,两两比较,交换来排序
        快速排序: 分治,基准,左右两边大小分开,递归
    选择排序:
        简单选择排序: 选最小的与待排序列开头交换
        堆排序(二叉堆): 完全二叉树顺序存储结构(非遍历顺序)(根,左,右,左左,右右,左左左...).根节点元素大于或小于节点元素;2i,2i+1;
    归并和基数排序:
        归并排序: 两个或两个以上的有序表组成一个新的表
        基数排序: 从低位到高位排序...

关键路径算法: |
    AOE 网
    顶点表事件,边表活动
    事件对前驱有全依赖性(前驱全完成后才能开始);star
    算的是,,没有可拖延时间的活动,,总的路径叫关键路径
    ve(i),事件i的最早发生时间,前面的全完成后启动i的最早时间
    vl(i),事件i的最迟发生时间,从后往前算,最小的时间点
    e(i),活动开始的最早开始时间,跟开始时间最早开始时间一致
    l(i),终点所表示的事件最迟发生时间与该活动所需时间之差
    d(i)=l(i)-e(i)

字符串模式匹配:
    简单的模式匹配: null
    改进的模式匹配(KMP):
        - 利用部分匹配的结果(最长公共前缀);
        - 字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串;
        - 排除当前的前面的比较结果,当要算next[j]时,意味着,j位没有对应上,next[j]是,公共前缀之后一个位置.因为前面的看作相同的,就要比较后一位是否相同.next的更新也是看这个;
        - ;这个next居然是1开头的,0保留.也对.;k=next[j-1],是为了next[j]=k+1,有两层跳跃;
        - ;next[j]是j错了前面的最长前缀后面的一位.

主存与Cache间的地址映射:
    全相联映射方式:对于主存中的数据块可以拷贝到cache中的哪一行不做硬性规定。
    直接映射方式: 相当于将主存空间按cache的大小（行数）进行分区（说“分组”也可以），主存分区（组）后，每区（组）中的数据块数目与cache的行数一致。
    组相连映射: cache的分组数=主存每一组的块数;将cache的空间分为若干组，主存块与cache组之间直接映射，而组内各块之间全相联映射。

微程序:
    微指令:
        微操作命令: 微命令是微操作的控制信号，微操作是微命令的执行过程。

# 相容性的微命令放在不同组，互斥性的命令放在一组。

字段直接编码: 就是把微命令分多个段，段的数目等于互斥类的数目。因此这里分为5个段，每段里要留一个离散状态表示自己没命令。所以7个微命令对应3位，3个微命令对应2位，12个微命令对应4位，5个微命令对应3位，6个微命令对应3位，共15位。

read系统调用:
    - 若文件的数据不在内存中，则进程进入睡眠模式的目的是等待内存对磁盘上文件的映射，因为磁盘的读取比较慢，所以事进入睡眠模式。
    - read是系统调用，所以CPU从用户态切换到核心态。
    - open系统调用应该包含文件的名称，read只是包含输入流


RL旋转: 新加的做根.其余做子数接到根上.