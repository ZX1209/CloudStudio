## 2.1 数制与编码
### 2.1.1 进位计数制与相互转换

#### 进位计数法
#### 不同进制之间的相互转换

### 2.1.2 真值和机器数
### 2.1.3 BCD 码
### 2.1.4 字符与字符串
#### 字符编码ASCII码
#### 汉字的表示和编码
GB 2312-1980 每个编码用两字节表示

GB 18030 用 1,2,4 B 表示

### 2.1.5 校验码
#### 奇偶校验码
#### 海明(汉明)校验码
#### 循环冗余校验(CRC)
左移R位,给校验位
与生成多项式左模2除法,生成一个R位校验码

模2除法: 加法和减法结果相同,都是做异或运算,不借位

得到余数是多少,就说明哪位出错(从右往左数,从1开始)


## 2.2 定点数的表示与运算
### 2.2.1 定点数的表示
#### 无符号数和有符号数的表示
#### 机器数的定点表示
根据小数点的位置是否固定,分为定点数与浮点数

##### 定点小数
符号位,小数点位(隐含),数值部分
##### 定点整数
符号位,数值部分,小数点位(隐含)


#### 原码,补码,反码,移码
由原码求补码,由补码求反码
对于正数,原反补相同
对于负数, 原码符号位不变,数值部分按位求反,末位加1,此规则同样适用于求补码和原码 :star: 



### 2.2.2 定点数的运算

#### 定点数的位移运算
##### 算术位移
符号位不变,移位后都相当于对真值补零

##### 逻辑位移
将操作数都视为无符号数,左右移都添零.
##### 循环位移

#### 原码定点数的加减法运算
#### 补码定点数加减法运算
#### 符号扩展
#### 溢出概念和判别方法
#### 定点数的乘法运算
#### 定点数的除法运算

### 2.2.3 C语言中的整数类型及类型转换
#### 有符号数和无符号数的转换

#### 不同字长整数之间的转换
当大字长变量向小字长变量强制类型转换时,系统把多余的高位字长部分直接截断,低位直接赋值

短字长到长字长整数的转换,不仅要使相应的位值相等,高位部分还会扩展为原数字的符号位

### 2.2.4 数据的存储和排列
#### 数据的大端方式与小端方式存储
对于1234H
大端: 1 2 3 4
小端: 4 3 2 1

大端方式按从高有效字节到最低有效字节的顺序存储数据
通常用大端

#### 数据按 边界对齐 方式存储
假设存储字长为32位,可按字节,半字,和字寻址,
数据以边界对齐方式存放,半字一定是2的倍数,字地址一定是4的倍数

填充空白字


## 2.3 浮点数的表示与运算'
### 2.3.1 浮点数的表示
#### 浮点数的表示格式
#### 规格化浮点数
#### 浮点数的表示范围
#### IEEE754 标准
##### 符号位
0表示正数,1表示负数

##### 阶码 8,11
首先,用无符号整数的方式解析存储的值
存储值 - 127 才得到实际的阶码

实际阶码 + 127 得到 存储值


注意八位二进制的话,最高位表示 128

移127的话,存储位 1000 0000  表示 阶码 1

移码 1000 0010  值为 129 表示 阶码为 3



##### 尾数 23,52

尾数采用隐藏位策略的原码表示(只有小数位)

整数部分的 1 将不存储在23位尾数内(没有整数部分的1,执行阶操作)
在浮点格式中表示的23位尾数是纯小数



#### 定点,浮点表示的区别

浮点数,规格化后阶码超出所能表示的范围时才发生溢出

### 2.3.2 浮点数的加减运算
浮点数的加减运算一律采用补码(存储用的是原码)
#### 对阶
使两个数的阶码相等
小阶向大阶看齐

#### 尾数求和
将对阶后的尾数(转化为补码)按定点数加减规则运算



#### 规格化
当尾数的最高数值位(包含)与符号位不同时,即为规格化形式

1. 左规
   2. 出现 00.0 或 11,1 时,需左规,直到尾数为 00.1 或 11.0
3. 右规
   4. 尾数为 10.x 或 01.x 时,需右规,

#### 舍入
#### 溢出判断
#### C语言中的浮点数类型及类型转换
强制类型转换的结果保持位值不变,只改变了解释这些位的方式(short,ushort?)

## 2.4 算术逻辑单元(ALU)
## 2.4 本章小结
## 2.6 常见问题和易混淆知识点