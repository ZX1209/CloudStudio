! 废弃 待转移


# 杂
ALU:算术逻辑单元(arithmetic and logic unit)

n位表示2^n种不同的对象.?

有符号整数:0表正,1表负?

负数表示形式:
  原码:符号位||数的绝对值
  反码:符号位||数值按位求反
  补码:反码的最低位+1

正数均相同

补码的加法运算
符号位和数据位同样计算

x补与-x补
x补连同符号位在内,逐位求反,再在最低位+1即可得到[-x]补

由x补求[x/2]补的方法
原符号位不变,且符号位与数值位均右移一位
10010,110010

不同位数的整数补码相加减时,要进行符号位扩展
位数少的补码数的符号位向左扩展,知道与另一数的符号位对齐.

```yaml
# 码矩
奇偶: 保持奇偶,并行
汉明码(海明码):
 r与k的关系: 2^k>=n+k+1;校验位位数为k,数据位位数为n;
 步骤: |
  1.校验位pi插放在2的幂次方位置
  2.数据位编号出现了那个2的i次方,pi就负责校验校验该数据位;3=1+2;(除总校验位)
  3.需要校验位异或
  4. 总校验位全数据异或
 校验: |
  1. si = pi 异或 现在数据组成的pi
  2. 无错 四位s全0
  3. 一位错 最高为必为1,其余位不全不为0
  4. 两位错 最高为必为0,其余位不全不为0
循环冗余

异或: 值不同为1
```

循环冗余码: "计算机网络有"


超前进位生成: null


布斯算法(补码乘法): |
 虽然乘法是加法的重复,但也可以将它理解成加法和减法的组合


浮点数的运算: null

实数的表示: 尾数,小数点,根,阶
二进制浮点数科学计数法: 尾数(实数部分,以一开头,表示小数点后面的,默认前面的是1),阶(基为2);规格化表示;

IEEE浮点数标准754:
    浮点数: X = MsEsEm...E2E1M-1M-2---M-n
    IEEE标准: |
        阶码用移码,对规格化数阶码用移127方案;E?;表示范围(-126~127),(全0表示最小负数,全1表示最大正数)(全0表示非规格化,全一表示无穷?)好处是可以用长度为n个比特的无符号整数来表示所有的指数取值(阶码总n个)
        阶码中的二进制用原码先解码,之后-127得到真正的阶码;
        尾数用原码,对规格化数的尾数用隐藏位技术;(0正,1负);M
        支持正负无穷大的浮点数和非规格化的浮点数
        设置一个非法浮点数编码供编程人员排错
    表头: 符号位,阶码(Exponent)位,尾数(Significand)位,总位数
    短浮点数(float): 1,8,23,32
    长浮点数(double): 1,11,52,64

# 移码: |
#     移码（英语：Offset binary）是一种将全0码映射为最小负值、全1码映射为最大正值的编码方案。移码没有标准，但通常对于n位二进制数，偏移量K = 2n−1——这使得真值0的编码的最高位为1、其余位均为0，相当于补码表示的最高位（符号位）取反；另外，移码在逻辑比较操作中可以得到和真值比较相同的结果，补码则当且仅当符号相同时逻辑比较操作的结果和真值比较相同，否则比较结果将颠倒（负值比正值大）。
#     上面是移128的
#     移码与补码的关系是符号位互为相反数???
#     E-127 = 阶码??? 实际的数值
#     码是在原码的基础上加的，原码的范围是-127到+127（有+0与-0）
#     阶码的范围是1到254，就是说阶码没有0与255的说法（无全0与全1）

浮点数最大最小值:
    最大值: (2-2^{-23})*2*^{127},即(1-2^{-24})*2*^{128}
    最小值: 1 * 2^{-126}

非规格化数: |
    最小的正数:a=2^{-150}
    次小的正数:b=2^{-149}

浮点数的运算: null

格雷码: 格雷码是一个数列集合，相邻两数间只有一个位元改变，为无权数码，且格雷码的顺序不是唯一的。

动态功耗: 与逻辑翻转频率成正比;格雷码

立即数(寻址): 所需的操作数在指令的地址字段部分直接给出
直接寻址: 直接给所需操作数在存储器中的地址.
寄存器寻址: 所需操作数在寄存器中
寄存器间接寻址: 寄存器中存放操作数在内存中的地址
变址寻址: 变址寄存器,地址偏移量
相对寻址: 与PC有关
间接寻址: 地址的地址
基址寻址: 基址计存器(非指令给出),指令中的地址码
堆栈寻址: null



单周期CPU: 全部指令都选用一个CPU周期完成的系统
多周期CPU: null
指令流水CPU: 全部指令都用5个步骤完成,执行时间相同,但相邻指令的执行并不是完全串行的,执行时间有所重叠.

指令执行过程:
    - 取指令(IF)
    - 指令译码(ID)
    - 执行指令(EXE)
    - 访问储存器(MEM)
    - 写回寄存器(WB)


流水寄存器: null

边界对齐储存:
    要点: 即对于存放某最大长度为m字节的数据，存放其他字节数据地址需在m字节的整数倍存放;结构体整体的大小是最大成员长度的整数倍;数据以最大成员长度为单元存放;
    参考: "https://blog.csdn.net/runner_of_nku/article/details/82883245"

DMA: Direct Memory Access,即直接存储器存取,快速传送数据,不需要CPU参与(但要与CPU共享总线(互斥)).

交叉存储器:
  参考: "https://blog.csdn.net/nuo_Shar/article/details/79048019 "
  地位交叉: 体号+体内地址
  高位交叉: 体内地址+体号;
  tmp: 地位交叉存储器是并行输出的，即连续读取4个字只需要一个存储周期，传送这四个字需要四个总线传送周期，而第一个字在存储周期内已经送到总线上并由总线传送了，而另外3个字则需要在存储周期结束后再等3个总线周期故200+3 * 50
  访存冲突: 只要在相邻的m个序列中，存在位于同一个存储体中的序列，他们就会发生访存冲突。（假设有m个体）

纯小数的表示: 最高位是符号位;+0.1101->0.1101B;-0.1101->1.1101B

逻辑位移: 移丢,添0;

补码运算:
    加减: 符号位与数值位一起运算,进位丢失;
    乘除:
    结构: 也是补码

补码一位乘法(Booth算法):
    - 符号位参与运算
    - 被乘数,部分积取双符号位,乘数可取单符号位
    - 乘数末位增设附加位,初值为0
    - 根据(yn,yn+1)的取值确认操作
    - 11,00,直接右移
    - 10,-x补,右移;01,+x补,右移;
    - 相当于,11,10的拆东补西?

补码除法: null

双符号位: 两个符号不同表溢出;高位表真正符号;从右到左,从低到高

顶点数的除法: null


IO请求的系统处理流程: 用户程序,系统调用程序,设备驱动程序,中断处理程序


补码: -0 表示为 -128(10000000); -127(10000001),比正数多一个





Cache:
  _values: [
  组 行,
  其余地址为加tag
  ]
  写回: 增加写回位
  直接映射: 主存中的一个块只能映射到Cache的某一特定块中去;依Cache块数份内存的组
  全相连映射: 主存中任何一块都可以映射到Cache中的任何一块位置上;
  组相联映射: 主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的
  地址位: tag set line;存储tag?
  其他位: [
    valid 位 此位置是否被映射,
    修改位 写回操作中加入的
  ]

SDRAM: 周期性刷新

DRAM: 行列地址线复用

总线定时:
  定义: 总线在双方交换数据的过程中需要时间上配合关系的控制。这种关系称为总线定时。实质是一种协议或规则。有同步与异步两种。
  同步定时: 系统采用统一的时钟信号来协调发送接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期，一个总线周期，可进行一次数据传输。且强制性同步。适用于总线长度简短，总线所接部件存取时间较为接近的系统。
  异步定时: [
    没有统一的时钟，没有固定的时间间隔。完全依靠双方相互制约的“握手”信号实现定时控制。类似计算机网络的TCP协议,
    异步定时再分为,
    不互锁,
    半互锁,
    全互锁,
    其中不互锁可以这样理解，一方，比如说A发过来信号，请求总线，请求发完就不管了，在正常时间内，另一方B发来响应，然后B也不管是不是A能正常收到。所以全靠自觉,
    半互锁的理解是这样的过程：A发来请求信号，它不会再去干其他事，它要等！它是负责任的，它要确定拿到B的响应。好，这里的锁便是A被锁定在了这个任务上，不能走开。但B是自由的，它姗姗发来响应，然后又飘然而走，不管A是怎样的心情,
    那么全互锁就是A、B都是被限制的了。A发来请求，它等着B发来响应，B发完响应就想跑吗？不可能，要等着A确认。
  ]
  同步通信: 统一时钟信号
  半同步通信: 握手信号的采样有同步时钟控制

  编码方案:
    归零(RZ): 一个周期内正电平为1负电平为0,信号结束归0电平
    非归零(NRZ):  传输过程不再归零
    NRZI: 电平反转代表1或0 inverted;一遍反转表0
    曼彻斯特: 中间跳变即作时钟信号又作数据;一般低到高表示 0
    差分曼彻斯特: 每位开始有跳变为 0



CISC特点: [
  CISC的指令系统复杂庞大，各种指令使用频度相差很大,
  指令字长不固定，指令格式多，寻址方式多,
  可以访存的指令不受限制,
  CPU中设有专用寄存器,
  绝大多数指令需要多个时钟周期方可执行完毕,
  采用微程序控制器,
  难以用优化编译生成高效的目标代码。
]

RISC特点: [
   CPU中有多个通用寄存器,
   采用流水线技术，大部分指令在一个时钟周期内完成。采用超标量和超流水线技术，可使每条指令的平均执行时间小于一个时钟周期,
   控制器采用组合逻辑控制，不用微程序控制,
   采用优化的编译程序,
   只有取数/存数指令访问存储器，其余指令的操作都在寄存器内完成,
   指令长度固定，指令格式种类少，寻址方式种类少,
   选取使用频度较高的一些简单指令以及一些很有用但又不复杂的指令，让复杂指令的功能由频度高的简单指令的组合来实现
]