# 杂
ALU:算术逻辑单元(arithmetic and logic unit)

n位表示2^n种不同的对象.?

有符号整数:0表正,1表负?

负数表示形式:
  原码:符号位||数的绝对值
  反码:符号位||数值按位求反
  补码:反码的最低位+1

正式均相同

补码的加法运算
符号位和数据位同样计算

x补与-x补
x补连同符号位在内,逐位求反,再在最低位+1即可得到[-x]补

由x补求[x/2]补的方法
原符号位不变,且符号位与数值位均右移一位
10010,110010

不同位数的整数补码相加减时,要进行符号位扩展
位数少的补码数的符号位向左扩展,知道与另一数的符号位对齐.

```yaml
# 码矩
奇偶: 保持奇偶,并行
汉明码(海明码):
 r与k的关系: 2^k>=n+k+1;校验位位数为k,数据位位数为n;
 步骤: |
  1.校验位pi插放在2的幂次方位置
  2.数据位编号出现了那个2的i次方,pi就负责校验校验该数据位;3=1+2;(除总校验位)
  3.需要校验位异或
  4. 总校验位全数据异或
 校验: |
  1. si = pi 异或 现在数据组成的pi
  2. 无错 四位s全0
  3. 一位错 最高为必为1,其余位不全不为0
  4. 两位错 最高为必为0,其余位不全不为0
循环冗余

异或: 值不同为1
```

循环冗余码: |
 "计算机网络有"


超前进位生成: null


布斯算法(补码乘法): |
 虽然乘法是加法的重复,但也可以将它理解成加法和减法的组合


浮点数的运算: null

实数的表示: 尾数,小数点,根,阶
二进制浮点数科学计数法: 尾数(实数部分,以一开头,表示小数点后面的,默认前面的是1),阶(基为2);规格化表示;

IEEE浮点数标准754:
    浮点数: X = MsEsEm...E2E1M-1M-2---M-n
    IEEE标准: |
        阶码用移码,对规格化数阶码用移127方案;E?;表示范围(-126^127),全0全1有特殊定义
        尾数用原码,对规格化数的尾数用隐藏位技术;(0正,1负);M
        支持正负无穷大的浮点数和非规格化的浮点数
        设置一个非法浮点数编码供编程人员排错
    表头: 符号位,阶码(Exponent)位,尾数(Significand)位,总位数
    短浮点数(float): 1,8,23,32
    长浮点数(double): 1,11,52,64

移码: |
    整数补码+偏移值;使浮点数0的机器表示表示为全0;看做无符号数,,,移127,移1023
    移码（英语：Offset binary）是一种将全0码映射为最小负值、全1码映射为最大正值的编码方案。移码没有标准，但通常对于n位二进制数，偏移量K = 2n−1——这使得真值0的编码的最高位为1、其余位均为0，相当于补码表示的最高位（符号位）取反；另外，移码在逻辑比较操作中可以得到和真值比较相同的结果，补码则当且仅当符号相同时逻辑比较操作的结果和真值比较相同，否则比较结果将颠倒（负值比正值大）。
    上面是移128的
    移码与补码的关系是符号位互为相反数???
    E-127 = 阶码???
    码是在原码的基础上加的，原码的范围是-127到+127（有+0与-0）
    阶码的范围是1到254，就是说阶码没有0与255的说法（无全0与全1）

浮点数最大最小值:
    最大值: (2-2^{-23})*2*^{127},即(1-2^{-24})*2*^{128}
    最小值: 1 * 2^{-126}

非规格化数: |
    最小的正数:a=2^{-150}
    次小的正数:b=2^{-149}

浮点数的运算: null

格雷码: 格雷码是一个数列集合，相邻两数间只有一个位元改变，为无权数码，且格雷码的顺序不是唯一的。

动态功耗: 与逻辑翻转频率成正比;格雷码

立即数(寻址): 所需的操作数在指令的地址字段部分直接给出
直接寻址: 直接给所需操作数在存储器中的地址.
寄存器寻址: 所需操作数在寄存器中
寄存器间接寻址: 寄存器中存放操作数在内存中的地址
变址寻址: 变址寄存器,地址偏移量
相对寻址: 与PC有关
间接寻址: 地址的地址
基址寻址: 基址计存器(非指令给出),指令中的地址码
堆栈寻址: null



单周期CPU: 全部指令都选用一个CPU周期完成的系统
多周期CPU: null
指令流水CPU: 全部指令都用5个步骤完成,执行时间相同,但相邻指令的执行并不是完全串行的,执行时间有所重叠.

指令执行过程:
    - 取指令(IF)
    - 指令译码(ID)
    - 执行指令(EXE)
    - 访问储存器(MEM)
    - 写回寄存器(WB)


流水寄存器: null

边界对齐储存:
    要点: 即对于存放某长度为m字节的数据，存放地址需在m字节的整数倍存放;结构体整体的大小是最大成员长度的整数倍;
    参考: "https://blog.csdn.net/runner_of_nku/article/details/82883245"

DMA:Direct Memory Access,即直接存储器存取,快速传送数据,不需要CPU参与(但要与CPU共享总线(互斥)).

交叉存储器:
  参考: "https://blog.csdn.net/nuo_Shar/article/details/79048019 "
  地位交叉: 体号+体内地址
  高位交叉: 体内地址+体号;
  tmp: 地位交叉存储器是并行输出的，即连续读取4个字只需要一个存储周期，传送这四个字需要四个总线传送周期，而第一个字在存储周期内已经送到总线上并由总线传送了，而另外3个字则需要在存储周期结束后再等3个总线周期故200+3 * 50

纯小数的表示: 最高位是符号位;+0.1101->0.1101B;-0.1101->1.1101B

逻辑位移: 移丢,添0;

补码运算:
    加减: 符号位与数值位一起运算,进位丢失;
    乘除:
    结构: 也是补码

补码一位乘法(Booth算法):
    - 符号位参与运算
    - 被乘数,部分积取双符号位,乘数可取单符号位
    - 乘数末位增设附加位,初值为0
    - 根据(yn,yn+1)的取值确认操作
    - 11,00,直接右移
    - 10,-x补,右移;01,+x补,右移;
    - 相当于,11,10的拆东补西?

补码除法: null

双符号位: 两个符号不同表溢出;高位表真正符号;从右到左,从低到高

顶点数的除法: null


IO请求的系统处理流程: 用户程序,系统调用程序,设备驱动程序,中断处理程序