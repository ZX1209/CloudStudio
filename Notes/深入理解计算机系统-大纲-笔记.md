##  前言
###   本书概述
* 第一章:计算机系统漫游
  * 研究简单程序的声明周期,介绍计算机系统的主要概念和主题
* 第二章:信息的表示和处理 (程序结构和执行)
* 第三章:程序的机器机表示
  * 教读者如何阅读由C编译器生成的汇编语言
* 第四章:处理器体系结构
  * 基本的组合和时序逻辑电路
* 第五章:优化程序性能
  * 提高代码性能的级数
* 第六章:储存器层次结构
* 第七章:链接 (在系统上运行程序)
  * 静态和动态链接
* 第八章:异常控制流
* 第九章:虚拟存储器
* 第十章:系统级IO (程序间的交互和通信)
  * Unix IO 的基本该奶奶
* 第十一章:网络编程
* 第十二章:并发编程


##  第一章:计算机系统漫游
###   1.1 信息就是位加上下文
###   1.2 程序被其它程序翻译成不同格式
* 预处理阶段
  * cpp
  * .i
* 编译阶段
  * ccl
  * .s
* 汇编阶段
  * as
  * .o
* 链接阶段
  * ld 
  * 二进制






##  第二章:信息的表示和处理
![](../Resources/深入理解计算机系统-大纲-笔记/2021-03-02-16-34-22.png)

##  第三章:程序的机器机表示
基于条件数据传送的代码会比基于条件控制转移的代码性能要好(流水线)

控制流不依赖于数据,这使得处理器更容易保持流水线是满的


###   3.7.6 递归过程
##  3.8 数组分配和访问
###   3.7.5 变长数组
malloc,free
c99
##  3.9 异质的数据结构
###   3.9.1 结构
struct
```c
struct point {
  int x;
  int y;
};
struct point p1;

typedef struct point2 {
  int x;
  int y;
} thep;
thep p2;
```

数组a(int a[2])是嵌入到这个结构中的

结构的地址加上该字段的偏移量



###   3.9.2 联合
联合的总大小等于它最大字段的大小
叠加,重合
###   3.9.3 数据对齐
##  3.10 在机器级程序中将控制与数据结合起来
###   3.10.1 理解指针

指针也可以指向函数
括号不可少,否则解读为函数原型定义
```c
int fun(int s,int *p);

int (*fp)(int ,int *);
fp = fun;

int y = 1;
int result = fp(2,&y);
```

###   3.10.2 应用: 使用GDB调试器
gdb.md
###   3.10.3 内存越界引用和缓冲区溢出
缓冲区溢出(buffer overflow),在栈中分配某个字符数组来保存一个字符串,但是字符串的超出了为数组分配的空间


##  第四章:处理器体系结构
##  第五章:优化程序性能
##  第六章:储存器层次结构
##  第七章:链接

###   7.1 编译器驱动程序
shell 调用操作系统中一个叫做加载器(loader)的函数,将可执行文件中的代码和数据复制到内存,然后将控制转移到这个程序的开头

###   7.2 静态链接
目标文件纯粹是字节块的集合
这些块中,有些包含程序代码,有些包含程序数据,而其它的则包含引导链接器和加载器的数据结构
链接器将这些块链接起来,确定被连接块的运行时位置,并且修改代码和数据块中的各种位置


###   7.3 目标文件
目标文件有三种形式:
* 可重定位目标文件
  * 二进制代码和数据
* 可执行目标文件
  * 可以被直接复制到内存并执行
* 共享目标文件
  * 特殊类型的可重定位目标文件,可以在加载或运行时被动态地加载进内存并链接


目标文件是按照特定的目标文件格式来组织的,各个系统的目标文件格式都不相同
unix,a.out
windows,portable executable ,pe
mac,mach-O
现代 linux, 可执行可链接格式(executable and linkable format,ELF)



###   7.4 可重定位目标文件
ELF头,十六字节的序列开始

![](../Resources/深入理解计算机系统-大纲-笔记/2021-03-03-13-40-23.png)

objdump -d


###   7.5 符号和符号表
三种不同符号
* 由模块 m 定义,并能被其它模块引用的全局符号
  * 对应于 非静态的C函数和全局变量
* 由其它模块定义并被模块m引用的全局符号,
  * 称为 外部符号 ,
  * 对应于在其它模块中定义和引用的非静态C函数和全局变量
* 只被模块美定义和引用的局部符号,
  * 对应于带static属性的C函数和全局变量
  * 这些符号在模块m中 任何位置都可见,但是不能被其它模块引用


`readelf -a`
###   7.6 符号解析

####    7.6.1 链接器如何解析多重定义的全局符号
函数和已初始化的全局变量是强符号
未初始化的全局变量是弱符号

* 不允许有多个同名的强符号
* 如果有一个强符号和多个弱符号同名,那么选择强符号
* 如果有多个弱符号同名,那么从这些弱符号中任意选择一个
####    7.6.2 与静态库链接

在linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中
存档文件是一组连接起来的棵重定位目标文件的集合,有一个头部用来秒数每个成员目标文件的大小和位置,
存档文件名由后缀.a标识

####    7.6.3 链接器如何使用静态库来解析引用
库的顺序可能造成引用失败


###   7.7 重定位
####    7.7.1 重定位条目


####    7.7.2 重定位符号引用
重定位PC相对引用
重定位绝对引用



###   7.8 可执行目标文件
可执行目标文件的格式类似于可重定位目标文件
还包括程序的入口点,.init节

可执行文件的连续片被映射到连续的内存段.
程序头部表描述了这种映射关系



###   7.9 加载可执行目标文件
shell通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它

任何linux程序都可以通过调用execve函数来调用加载器

加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或入口点来运行该程序,
这个将程序复制到内存并运行的过程叫做 加载



###   7.10 动态链接共享库
`gcc -shared -fpic -o libvector.so addvec.c multvec.c`
`gcc -o prog21 main2.c ./libvector.so`

没有任何 libvector.so 的代码和数据节真的被复制到可执行文件中,
反之链接器复制了一些重定位和符号信息表信息
它们使得运行时可以解析对 libvector.so 中代码和数据的引用

.interp

ld-linux.so





###   7.11 从应用程序中加载和链接共享库
```c
#include <dlfcn.h>

void * dlopen(char *filename,int flag); # 加载和链接共享库filename

void *dlsym(void * handle,char *symbol); # 如果符号存在,就返回符号的地址,否则返回NULL

void *dlclose(void * handle); # 如果没有其它共享库还在使用这个共享库,dlclose函数就卸载该共享库
const char *dlerror(void); # 前面dl调用出错,则为错误消息,否则为NULL
```
###   7.12 位置无关代码
可以加载而无需重定位的代码称为位置无关代码(position-independent code,PIC)
拥护对GCC使用-fpic选项指示GUN编译系统生成PIC代码.共享库的编译必须总是使用该选项

?



###   7.13 库打桩机制
linux 链接器支持一个很强大的技术,称为库打桩(library interpositioning)
它允许你截获对共享库函数的调用,取而代之执行自己的代码

下面是它的基本思想:
给定一个需要打桩的目标函数,创建一个包装函数,它的原型与目标函数完全一样

####    7.13.1 编译时打桩
####    7.13.2 连接时打桩
####    7.13.3 运行时打桩

###   7.14 处理目标文件的工具
ar: 创建爱呢静态库,插入,删除,列出和提取成员
strings: 列出一个目标文加中所有可打印的字符串
strip: 从目标文件中删除符号表信息
nm: 列出一个目标文件的符号表中定义的符号
size: 类出目标文件中节的名字和大小
readelf: 显示一个目标文件的完整将诶够
objdump: 所有二进制工具之母
ldd: 列出一个可执行文件在运行时所需要的共享库
###   7.15 小结

静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。

动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。

##  第八章:异常控制流
##  第九章:虚拟存储器
##  第十章:系统级IO
##  第十一章:网络编程
##  第十二章:并发编程

mkdir 1-第一章:计算机系统漫游       
mkdir 2-第二章-信息的表示和处理
mkdir 3-第三章-程序的机器机表示
mkdir 4-第四章-处理器体系结构
mkdir 5-第五章-优化程序性能
mkdir 6-第六章-储存器层次结构
mkdir 7-第七章-链接
mkdir 8-第八章-异常控制流
mkdir 9-第九章-虚拟存储器
mkdir 10-第十章-系统级IO
mkdir 11-第十一-网络编程
mkdir 12-第十二-并发编程