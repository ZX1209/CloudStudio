## 8.1 排序的基本概念
### 8.1.1 排序的定义
重新排列表中的元素,是表中元素满足按关键字有序的过程

算法稳定性: 排序后相同关键字的元素顺序不变

内部排序: 排序期间元素全部存放在内存中

外部排序: 排序期间元素无法全部同时存放在内存中

## 8.2 插入排序
每次将一个待排序的记录按关键字大小插入到前面已排好序的子序列中,直到全部记录插入完成

### 8.2.1 直接插入排序
排序过程中末裔时刻状态如下:
有序序列 L[i] 无序序列

要将元素L[i]插入到已有的子列L[1...i-1]中,需要执行以下操作:
1. 查找L[i]在L[1...i-1]中的插入位置k
2. 将L[k...i-1]中所有元素依次后移一个位置
3. 将L[i]复制到L[k]

### 8.2.2 折半插入排序
先折半查找哦出元素的待插位置,然后统一的移动插入位置之后的所有元素

### 8.2.3 希尔排序
直接插入排序算法的时间复杂度为P(n²),但若待排序为 正序 是 其时间复杂度可提高至O(n)
希尔排序又称缩小增量排序

希尔排序的基本思想是:
先将待排序表分割称若干形如L[i,i+d,i+2d,...,i+kd] 的特殊子表
即把相隔某个增量的记录组成一个子表
对各个子表分别进行直接插入排序,
当整个表中元素已呈现 基本有序 时, 再对全体记录进行一次**直接插入排序**



希尔排序的过程如下
1. 先取一个小于n的步长d1
2. 把表中的全部记录分成d1组,分割成 特殊子表
3. 再进行直接插入排序
4. 然后取第二个步长d2 < d1,重复上述过程,直到所取
5. 的dt = 1

d1 = n/2
d_{i+1} = ⌊  di/2 ⌋
最后一个增量取1

不稳定

## 8.3 交换排序
### 8.3.1 冒泡排序
从后往前,两两比较相邻元素的值,若为逆序(A[i]>A[i+1]),则交换它们
顺序是从小到大吗

稳定O(n²)
### 8.3.2 快速排序
基于分治法

在待排序表L[1...n]中任取一个元素与pivot 作为枢轴(或基准,通常取首元素),
通过一趟排序将排序表划分为独立的两部分L[1...k-1]和L[k+1...n]
使得L[1...k-1]中所有元素小于pivot,L[k+1...n]中所有元素大于等于pivot
则pivot放在最终位置k上,这个过程称为一趟快速排序
然后分别递归地对两个子表重复上述过程,直到每部分内只有一个元素或为止
即所有元素放在了其最终位置上

空间效率: 最好 O(log₂n),最坏 O(n),平均O(log₂n)
时间效率: 最坏 O(n²)
快速排序是所有内部排序算法中平均性能最优的排序算法

不稳定

## 8.4 选择排序
每一躺(如第i躺)在后面n-i+1个待排序元素中选取关键字最小的元素,最为有序子序列的第i个元素


### 8.4.1 简单选择排序

时间效率: O(n²)

不稳定

### 8.4.2 堆排序
堆的定义如下,n个关键字序列L[1...n]称为对,当且仅当该序列满足:
1. L[i] ≥ L[2i] 且L[i]≥L[2i+1] 或
2. L[i] ≤ L[2i] 且L[i]≤L[2i+1]

可以将该一维数组视为一棵完全二叉树,满足条件1的堆称为大根堆(大顶堆)
满足条件2的称为小根堆(小顶堆)

堆排序的思路很简单: 首先将存放在L[1...n]中的n个元素建成初始堆
此时堆顶元素就是最大值,输出堆顶元素
将堆底元素元素送入堆顶,将堆顶元素向下调整使其依然保持大根堆的性质
如此重复,直到仅剩一个元素为止

构造初始堆:
n个节点的完全二叉树,最后一个节点是 ⌊ n/2 ⌋ 个节点的孩子节点,最第⌊ n/2 ⌋个节点为根的子树进行筛选
(若根节点的关键字小于左右孩子中关键字较大者,则交换),使该子数成为堆
之后,一次对各节点(⌊ n/2 ⌋-1∼1)为根的子树进行筛选

交换后可能会破坏下一级的堆,于是继续采用上述芳芳构造下一级的堆(下面一层)

堆插入,将新节点房子啊堆的末端,再对这个新节点向上执行调整操作

堆排序适合关键字较多的情况,在1亿个数中选出前100个最大值

时间复杂度: O(nlog₂n)

不稳定

## 8.5 归并排序和基数排序
### 8.5.1 归并排序
归并的含义是将两个或两个以上的有序表组合称一个新的有序表

递归形式的2路归并排序算法基于分治,其过程如下:
分解: 将含有n个元素的带排序序列表分成各含n/2个元素的子表,采用2路归并算法对两个子表递归地进行排序
合并: 合并两个已排序的子表得到排序结果

时间复杂度: O(nlog₂n)
### 8.5.2 基数排序
基于关键字各位的大小进行排序

最高位优先(MSD),按关键字位权重递减一次逐层划分称若干更小的子序列
最低位优先(LSD),按关键字权重递增一次进行排序,最后形成一个有序序列

链式基数排序

与关键字的初始排列次序无关

## 8.6 各种内部排序算法的比较及应用

### 8.6.1 内部排序算法的比较


### 8.6.2 内部排序算法的应用

任何借助于  比较的算法 至少要 O(nlog₂n)时间

n很大,且关键字可分解时,用基数排序较好

## 8.7 外部排序
### 8.7.1 外部排序的基本概念
外部排序过程中,主要考虑访问磁盘的次数



### 8.7.2 外部排序的方法
通常采用归并法,它包括两个相对独立的阶段:
1. 根据内存缓冲区大小,将外存上的文件分成若干长度为l的子文件,依次度如内存,并排序
   1. 将排序后得到的有序子文件重新写回外存,称这些有序子文件为归并段或顺段
2. 归这些归并段进行逐躺归并,并使用归并段逐渐由小到大,指导整个有序文件为止
### 8.7.3 多路平衡归并与败者树
败者树是树形悬着排序的一种变体,可视为一颗完全二叉树
k个叶节点分别存放k个归并段在归并过程中当前参加比较的记录,内部节点哦嗯来记忆左右子树中的 失败者,而让胜者往上继续进行比较,直到根节点
若比较两个数,大的为失败者,小的为胜利者

k 路归并的败者树深度为 ⌈ log₂k ⌉,

remian...
### 8.7.4 置换-选择排序(生成初始归并段)
### 8.7.5 最佳归并树