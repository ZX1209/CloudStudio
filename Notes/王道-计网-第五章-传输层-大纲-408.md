## 5.1 传输层提供的服务
### 5.1.1 传输层的功能
传输层只存在于通信子网外的主机中

功能如下:
1. 提供应用程序进程之间的逻辑通信
2. 复用和分用,
   1. 不同应用都可使用同一个传输层协议,
   2. 接收方传输层在剥去报文后能把数据正确交付到目的应用进程
3. 对报文进行差错检测,网络层只检查IP数据报的首部
4. 提供两种不同的传输协议,




### 5.1.2 传输层的寻址与端口
#### 端口的作用
端口能够让应用层的各种应用进程将器数据通过端口向下交付给传输层
以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的相应进程
端口是传输层服务访问点TSAP,他在传输层的作用类似IP地址在网络层的作用

数据链路层的SAP是MAC地址,网络层的SAP是IP地址

#### 端口号
端口号长度为16bit,能表示2的16次方(65536)个不同的端口号

根据端口号反问可将端口号分为两类
1. 服务端使用端口号
   1. 熟知端口号,0~1023,IANA(互联网地址指派机构)把这些端口号指派给了TCP/IP最重要的一些程序
   2. 登记端口号,1024~49151,也要在IANA等记,以防重复
2. 客户端使用端口号
   1. 49152~65535
   2. 一般竟在客户进程运行时才动态选择,又称端在端口号,
   3. 通信结束后可供其他客户进程使用


常用熟知端口号
| 应用程序   | FTP | TELNET | SMTP | DNS | TFTP | HTTP | SNMP |
| ---------- | --- | ------ | ---- | --- | ---- | ---- | ---- |
| 熟知端口号 | 21  | 23     | 25   | 53  | 69   | 80   | 161  |

#### 套接字
在网络中采用发送方和接受方的套接字(Socket)组合来识别端点
所谓套接字,实际上是一个通信端点,即
套接字 = (主机IP地址,端口号)
它唯一标识网络中的一台主机和其上的应用(进程)

网络通信中,主机A发给主机B的报文段包含目的端口号和源端口号,
源端口号是返回地址的一部分,,,





### 5.1.3 无连接服务与面向连接服务

TCP不提供广播或组播服务,

ip数据报和UDP数据报的区别:

UDP数据报的信息对路由是不可见的?
???

## 5.2 UDP协议
无连接,不可靠 
### 5.2.1 UDP数据报

#### UDP 概述
优点:
1. 无需建立连接
2. 无连接状态
3. 分组首部开销小,TCP 20B,UDP 8B
4. UDP 没有拥塞控制

常用于一次传输较少数据的网络应用

报文不可分割(对UDP来说)

不保证可靠交付


#### UDP 首部格式
1. 源端口,不需要时可用全0
2. 目的端口,终点交付时必须用到
3. 长度,UDP数据报长度(包括首部和数据),最小值是8(B),仅有首部
4. 校验和,全为0表示不校验

16位源端口 16位目的端口
16位UDP长度 16位UDP检验和
数据 

如果接收方UDP发现收到的报文中的目的端口不正确,就丢弃该报文,并有ICMP发送 端口不可达 差错报文给发送方




### 5.2.2 UDP校验
在计算校验和时,要在UDP数据报之前增加12B的伪首部


发送方首先把全零放入校验和字段,并添加伪首部,然后把UDP数据报视为许多16位的字连起来
若UDP数据报的数据部分不是偶数个字节,则要在数据不稳末尾增加一个全零字节(但不发送)

接下来按二进制反码计算出这些16位字的和?,并将**此和的二进值反码**写入校验和字段
接收方吧收到的数据报加上伪首部,填充零字节,并按二进制反码计算出这些16位字的和,
当无差错时,其结果应全为1,否则表明有差错,接收方就应该丢弃这个UDP数据报

通过伪首部不仅可以检查源端口号,目的端口号和UDP数据报的数据部分,还可以减产IP数据报的源IP地址和目的地址

这种简单的差错检验方法检错能力并不强,但它的好处是简单,处理速度快




## 5.3 TCP协议
### 5.3.1 TCP 协议的特点
在不可靠的IP层之上实现的可靠的传输协议,主要就决传输的可靠,有序,无丢失和不重复问题
特点如下:
1. TCP是面向连接的传输层协议
2. 每条TCP连接只能有两个端点,每条TCP连接只能是点对点的
3. TCP提供可靠的交付服务
4. TCP提供全双工通信,连接两端都有缓存
   1. 发送缓存用来暂时存放,准备发送的数据,已发送但未收到确认的数据
   2. 接受缓存用来暂时存放,按序到达但尚未接收的数据,不按序到达的数据
5. TCP是面向字节流的,



### 5.3.2 TCP 报文段
TCP传送的数据单元称为报文段,一个TCP报文段分为TCP首部和TCP数据部分
整个TCP报文段作为IP数据报的数据部分封装在IP数据报中

TCP报文段首部最短为20B,后面有4N B 是根据需要而增加的选项,通常长度为4B的整数倍
![](../Resources/王道-计网-第五章-传输层-大纲-408/img_name2020-11-07-14-18-55.png)


TCP报文段既可以用来运载数据,又可以用来建立连接,释放连接和应答

各字段意义如下:
1. 源端口和目的端口字段,各占2B
2. 序号字段,占4B.指本报文段所发送的数据的第一个字节(Byte)的序号
3. 确认号字段,占4B.是期望收到对方的下一个报文段的数据的第一个字节的序号,表明到序号N-1为止的所有数据都已正确收到
4. 数据偏移(即首部禅度),站4位(bit),(不是IP数据报分片的那个数据偏移),表示首部长度,单位是32bit(4B),值为15时达到TCP首都最大长度60B
5. 保留字段,6 bit,保留今后使用
6. 紧急位URG.URG=1 时,表明紧急指针字段有效,???
7. 确认位ACK.当ACK=1 确认号字段才有效,当ACK=0时,确认号无效
8. 推送位PSH(Push).接收TCP收到PSH=1的报文段,就经快交付给接收应用进程,而不等整个缓存都填满后再向上交付
9. 复位位RST(Rest).RST=1是,表明TCP连接中出现严重差错,必须释放连接,然后重新建立运输连接
10. 同步位SYN.SYN=1 表示这是一个连接请求或连接接收报文
11. 终止位FIN(Finish).用来释放一个连接
12. 窗口字段.2B.指出**现在**允许对方发送的数据量(B),**以确认号为基**,
13. 校验和.2B.包括首部和数据两部分,计算校验和是,要在TCP首部加上12B 的伪首部(协议字段改为6,其他跟UDP一样)
14. 紧急指针字段,16bit,2B.之处本报文中紧急数据共有多少字节,紧急数据放在本报文段数据的最前面
15. 选项字段.长度可变,最大报文段长度(MSS),数据字段的最大长度
16. 填充字段.为了使整个首部长度是4B的整数倍





### 5.3.3 TCP 连接管理
TCP连接的端口称为套接字(socket)或插口


每条TCP连接唯一地被通信两端的套接字确定

#### TCP连接的建立
三次握手
1. SYN=1,sqe=x.不携带数据.客户端向服务器发送一个连接请求报文字段
2. SYN=1,ACK=1,确认号字段为 x+1,随机生成起始序号 seq=y,不携带数据.同意建立连接,向客户端发回确认,并为该TCP连接分配TCP缓存和变量
3. ACK=1,序号字段为x+1,确认号字段y+1,可携带数据.向服务器给出确认,给连接分配缓存和变量(SYN不为 1 呢)

#### TCP连接的释放
四次握手

第一步,客户机打算关闭连接时,向其TCP发送一个连接释放报文端,并停止发送数据,主动关闭TCP连接
该报文段的FIN标志位被置 1 ,seq=u,它等于前面已经传过的数据的最后一个字节的序号加1(FIN报文段即便不携带数据也要消耗一个序号)
第二步,服务器接收到连接释放报文段后即发出确认,确认号是ack=u+1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1
此时,从客户机到服务器这个方向上的连接就是释放了,TCP连接处于半关闭状态.
但服务器若发送数据,客户机仍要接受,
即从服务器到客户机这个方向的连接并未关闭
第三步,若服务器已经没有要向客户机发送的数据,就通知TCP释放连接,(->)此时其发出FIN=1 的连接释放报文段
第四步,客户机收到连接释放报文段后,必须发出确认.在确认报文中中,ACK字段被设置为1 ,确认号w+1,序号seq=u+1.
此时TCP连接还未释放,必须经过时间等待计时器设置的时间2MSL后,A才进入连接关闭状态

对上述TCP连接建立和释放的总结如下:
1. 连接建立,3步
   1. SYN=1,seq=x;客
   2. SYN=1,ACK=1,seq=y,ack=x+1;服
   3. ACK=1,seq=x+1,ack=y+1;客
2. 释放连接,4步
   1. FIN=1,seq=u;客
   2. ACK=1,seq=v,ack=u+1;服
   3. FIN=1,ACK=1,seq=w,ack=u+1;服
   4. ACK=1,seq=u+1,ack=w+1;客



### 5.3.4 TCP 可靠传输
#### 序号
序号建立在传送的字节流中,而不在报文段之上

序号字段的值是指本报文段所发的数据的第一个字节的序号(0开始)


#### 确认
TCP首部的确认号是期望收到对方的下一个报文段的第一个字节的序号
#### 重传
有两种事件会导致TCP对报文段进行重传:超时和冗余ACK

##### 超时
TCP每发送一个报文段,就对这个报文段设置一次计时器.计时器设置的重传时间到期但还未收到确认时,就要重传这一报文段

加权平均往返时间RTTs

超时重传时间(restransmission time out)RTO 应略大于RTTs

##### 冗余ACK
再次确认某个报文段的ACK,称为冗余ACK
TCP规定当发送方收到对同一个报文段的3个冗余ACK(收到不是期望序号时)时,就可以认为跟在这个被确认报文段之后的报文段已经丢失
快速重传




### 5.3.5 TCP 流量控制

接收窗口 rwnd,接收方根据自己**缓存大小**,动态调整发送方的发送窗口大小,即调整TCP报文段首部的 窗口 字段(现在允许发送的数据量),来限制发送方向的速率(B),
拥堵窗口 cwnd,发送方根据对当前网络拥塞程度的估计而确认的窗口值




### 5.3.6 TCP 拥堵控制
发送窗口的上限应取接收窗口和拥塞窗口的最小值

#### 慢开始和拥塞避免
##### 慢开始算法
TCP刚连接号并开始发送TCP报文段时,先令拥堵窗口cwnd=1
每收到一个**对新报文的确认**后,将cwnd加1
(收到两个确认就加2)

这样慢开始一直把拥堵窗口cwnd增大到一个规定的慢开始门线ssthresh(阈值),然后改用拥塞避免算法

##### 拥塞避免算法
发送端的拥塞窗口cwnd每经过一个RTT就正增加一个MSS(最大报文段长度),而不是加倍
而当出现一次超时时,令慢开始门限等于当前cwnd的一半
之后根据cwnd的大小执行不同的算法
* cwnd < ssthresh,使用慢开始算法
* cwnd > ssthresh,停止使用慢开始算法而改用拥塞避免算法
* cwnd = ssthresh,通常用拥塞避免算法,也可用慢开始

##### 网络拥塞的处理
网络出现拥塞时,无论是在慢开始阶段还是在拥塞避免阶段,
只要发送方检测到超时事件的发生,就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd的一般(但不小于2),然后把cwnd重新设置为1,执行慢开始算法

注意在慢开始(指数增长)阶段,若2*cwnd>ssthresh,则下一个RTT的cwnd等于ssthresh





#### 快重传和快恢复
##### 快重传 
快重传算法首先要求接收方每收到一个失序的报文段就立即发出重复确认（为的是使发送方及早的知道有报文段没有到达对方）而不要等到自己发送数据时才捎带确认。

快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期。

##### 快恢复
发送端接收到连续三个冗余ACK时,执行 乘法减小 算法
把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半
与慢开始不同之处为,它把cwnd的值设置为慢开始门限改变后的数值,然后执行拥塞避免算法


一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh （在有些版本中，会让 cwnd = ssthresh + 3）


用于跳过了 cwnd 从 1开始的慢开始过程,所以称为快恢复


## 5.4 本章小结及疑难点
MSS应尽量大,只要IP传输层不分片就行
默认536B,因此因特网上所有主机能够接收的报文段长度为 536+20 = 556B

为什么不采用三次握手释放连接
1. 保证A撒松的最后一个确认报文能够到达B
2. 防止出现 已失效的连接请求报文段

RTT对UDP没什么意义

